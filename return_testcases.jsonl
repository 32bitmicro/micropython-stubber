{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef open(stream, *, flags=0, pagesize=0, cachesize=0, minkeypage=0):\n    '''\n   Open a database from a random-access `stream` (like an open file). All\n   other parameters are optional and keyword-only, and allow to tweak advanced\n   parameters of the database operation (most users will not need them):\n\n   * *flags* - Currently unused.\n   * *pagesize* - Page size used for the nodes in BTree. Acceptable range\n     is 512-65536. If 0, a port-specific default will be used, optimized for\n     port's memory usage and/or performance.\n   * *cachesize* - Suggested memory cache size in bytes. For a\n     board with enough memory using larger values may improve performance.\n     Cache policy is as follows: entire cache is not allocated at once;\n     instead, accessing a new page in database will allocate a memory buffer\n     for it, until value specified by *cachesize* is reached. Then, these\n     buffers will be managed using LRU (least recently used) policy. More\n     buffers may still be allocated if needed (e.g., if a database contains\n     big keys and/or values). Allocated cache buffers aren't reclaimed.\n   * *minkeypage* - Minimum number of keys to store per page. Default value\n     of 0 equivalent to 2.\n\n   Returns a BTree object, which implements a dictionary protocol (set\n   of methods), and some additional methods described below.\n    '''\n\n\n-=-+-=-\n","completion": "BTree"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef btree.close():\n    '''\n   Close the database. It's mandatory to close the database at the end of\n   processing, as some unwritten data may be still in the cache. Note that\n   this does not close underlying stream with which the database was opened,\n   it should be closed separately (which is also mandatory to make sure that\n   data flushed from buffer to the underlying storage).\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef btree.flush():\n    '''\n   Flush any data in cache to the underlying stream.\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef btree.__getitem__(key):\n    '''\n            btree.get(key, default=None, /)\n            btree.__setitem__(key, val)\n            btree.__delitem__(key)\n            btree.__contains__(key)\n\n   Standard dictionary methods.\n    '''\n\n\n-=-+-=-\n","completion": "Dict"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef btree.__iter__():\n    '''\n   A BTree object can be iterated over directly (similar to a dictionary)\n   to get access to all keys in order.\n    '''\n\n\n-=-+-=-\n","completion": "Iterator[Any]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef btree.keys([start_key, [end_key, [flags]]]):\n    '''\n            btree.values([start_key, [end_key, [flags]]])\n            btree.items([start_key, [end_key, [flags]]])\n\n   These methods are similar to standard dictionary methods, but also can\n   take optional parameters to iterate over a key sub-range, instead of\n   the entire database. Note that for all 3 methods, *start_key* and\n   *end_key* arguments represent key values. For example, `values()`\n   method will iterate over values corresponding to they key range\n   given. None values for *start_key* means \"from the first key\", no\n   *end_key* or its value of None means \"until the end of database\".\n   By default, range is inclusive of *start_key* and exclusive of\n   *end_key*, you can include *end_key* in iteration by passing *flags*\n   of `btree.INCL`. You can iterate in descending key direction\n   by passing *flags* of `btree.DESC`. The flags values can be ORed\n   together.\n    '''\n\n\n-=-+-=-\n","completion": "Iterable[Tuple[Any, Any]]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef delattr(obj, name):\n    '''\n   The argument *name* should be a string, and this function deletes the named\n   attribute from the object given by *obj*.\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef WLAN.scan():\n    '''\n    Scan for the available wireless networks.\n\n    Scanning is only possible on STA interface. Returns list of tuples with\n    the information about WiFi access points:\n\n        (ssid, bssid, channel, RSSI, authmode, hidden)\n\n    *bssid* is hardware address of an access point, in binary form, returned as\n    bytes object. You can use `ubinascii.hexlify()` to convert it to ASCII form.\n\n    There are five values for authmode:\n\n        * 0 -- open\n        * 1 -- WEP\n        * 2 -- WPA-PSK\n        * 3 -- WPA2-PSK\n        * 4 -- WPA/WPA2-PSK\n\n    and two for hidden:\n\n        * 0 -- visible\n        * 1 -- hidden\n    '''\n\n\n-=-+-=-\n","completion": "List[Tuple[str, bytes, int, int, int, int]]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef poll.poll(timeout=-1, /):\n    '''\n   Wait for at least one of the registered objects to become ready or have an\n   exceptional condition, with optional timeout in milliseconds (if *timeout*\n   arg is not specified or -1, there is no timeout).\n\n   Returns list of (``obj``, ``event``, ...) tuples. There may be other elements in\n   tuple, depending on a platform and version, so don't assume that its size is 2.\n   The ``event`` element specifies which events happened with a stream and\n   is a combination of ``uselect.POLL*`` constants described above. Note that\n   flags ``uselect.POLLHUP`` and ``uselect.POLLERR`` can be returned at any time\n   (even if were not asked for), and must be acted on accordingly (the\n   corresponding stream unregistered from poll and likely closed), because\n   otherwise all further invocations of `poll()` may return immediately with\n   these flags set for this stream again.\n\n   In case of timeout, an empty list is returned.\n    '''\n\n\n-=-+-=-\n","completion": "List[Tuple]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef regex.split(string, max_split=-1, /):\n    '''\n   Split a *string* using regex. If *max_split* is given, it specifies\n   maximum number of splits to perform. Returns list of strings (there\n   may be up to *max_split+1* elements if it's specified).\n    '''\n\n\n-=-+-=-\n","completion": "List[str]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef RTC.datetime([datetimetuple]):\n    '''\n   Get or set the date and time of the RTC.\n\n   With no arguments, this method returns an 8-tuple with the current\n   date and time.  With 1 argument (being an 8-tuple) it sets the date\n   and time.\n\n   The 8-tuple has the following format:\n\n       (year, month, day, weekday, hours, minutes, seconds, subseconds)\n\n   The meaning of the ``subseconds`` field is hardware dependent.\n    '''\n\n\n-=-+-=-\n","completion": "Tuple[int, int, int, int, int, int, int, int]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef PWM.duty_u16([value]):\n    '''\n   Get or set the current duty cycle of the PWM output, as an unsigned 16-bit\n   value in the range 0 to 65535 inclusive.\n\n   With no arguments the duty cycle is returned.\n\n   With a single *value* argument the duty cycle is set to that value, measured\n   as the ratio ``value / 65535``.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef PWM.duty_ns([value]):\n    '''\n   Get or set the current pulse width of the PWM output, as a value in nanoseconds.\n\n   With no arguments the pulse width in nanoseconds is returned.\n\n   With a single *value* argument the pulse width is set to that value.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef cos(z):\n    '''\n   Return the cosine of ``z``.\n    '''\n\n\n-=-+-=-\n","completion": "float"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef unique_id():\n    '''\n   Returns a byte string with a unique identifier of a board/SoC. It will vary\n   from a board/SoC instance to another, if underlying hardware allows. Length\n   varies by hardware (so use substring of a full value if you expect a short\n   ID). In some MicroPython ports, ID corresponds to the network MAC address.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Pin.init(mode=-1, pull=-1, *, value, drive, alt):\n    '''\n   Re-initialise the pin using the given parameters.  Only those arguments that\n   are specified will be set.  The rest of the pin peripheral state will remain\n   unchanged.  See the constructor documentation for details of the arguments.\n\n   Returns ``None``.\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef mem_free():\n    '''\n   Return the number of bytes of available heap RAM, or -1 if this amount\n   is not known.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef SPI.read(nbytes, write=0x00):\n    '''\n    Read a number of bytes specified by ``nbytes`` while continuously writing\n    the single byte given by ``write``.\n    Returns a ``bytes`` object with the data that was read.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef bytes():\n    '''\n    |see_cpython| `python:bytes`.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef bytearray_at(addr, size):\n    '''\n   Capture memory at the given address and size as bytearray object.\n   Unlike bytes_at() function above, memory is captured by reference,\n   so it can be both written too, and you will access current value\n   at the given memory address.\n    '''\n\n\n-=-+-=-\n","completion": "bytearray"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef to_bytes(size, byteorder):\n    '''\n      In MicroPython, `byteorder` parameter must be positional (this is\n      compatible with CPython).\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef bytes_at(addr, size):\n    '''\n   Capture memory at the given address and size as bytes object. As bytes\n   object is immutable, memory is actually duplicated and copied into\n   bytes object, so if memory contents change later, created object\n   retains original value.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef polar(z):\n    '''\n   Returns, as a tuple, the polar form of ``z``.\n    '''\n\n\n-=-+-=-\n","completion": "Tuple[float, float]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef isnan(x):\n    '''\n   Return ``True`` if ``x`` is not-a-number\n    '''\n\n\n-=-+-=-\n","completion": "bool"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef WLAN.isconnected():\n    '''\n    In case of STA mode, returns ``True`` if connected to a WiFi access\n    point and has a valid IP address.  In AP mode returns ``True`` when a\n    station is connected. Returns ``False`` otherwise.\n    '''\n\n\n-=-+-=-\n","completion": "bool"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Pin.name():\n    '''\n   Get the pin name.\n    '''\n\n\n-=-+-=-\n","completion": "str"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef socket.makefile(mode='rb', buffering=0, /):\n    '''\n   Return a file object associated with the socket. The exact returned type depends on the arguments\n   given to makefile(). The support is limited to binary modes only ('rb', 'wb', and 'rwb').\n   CPython's arguments: *encoding*, *errors* and *newline* are not supported.\n    '''\n\n\n-=-+-=-\n","completion": "IO"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef repl_uart(uart):\n    '''\n   Get or set the UART object where the REPL is repeated on.\n    '''\n\n\n-=-+-=-\n","completion": "UART"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef BLE():\n    '''\n    Returns the singleton BLE object.\n    '''\n\n\n-=-+-=-\n","completion": "BLE"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef addressof(obj):\n    '''\n   Return address of an object. Argument should be bytes, bytearray or\n   other object supporting buffer protocol (and address of this buffer\n   is what actually returned).\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef LCD160CR.set_power(on):\n    '''\n    Turn the display on or off, depending on the given value of *on*: 0 or ``False``\n    will turn the display off, and 1 or ``True`` will turn it on.\n    '''\n\n\n-=-+-=-\n","completion": "bool"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Pin.value([x]):\n    '''\n   This method allows to set and get the value of the pin, depending on whether\n   the argument ``x`` is supplied or not.\n\n   If the argument is omitted then this method gets the digital logic level of\n   the pin, returning 0 or 1 corresponding to low and high voltage signals\n   respectively.  The behaviour of this method depends on the mode of the pin:\n\n     - ``Pin.IN`` - The method returns the actual input value currently present\n       on the pin.\n     - ``Pin.OUT`` - The behaviour and return value of the method is undefined.\n     - ``Pin.OPEN_DRAIN`` - If the pin is in state '0' then the behaviour and\n       return value of the method is undefined.  Otherwise, if the pin is in\n       state '1', the method returns the actual input value currently present\n       on the pin.\n\n   If the argument is supplied then this method sets the digital logic level of\n   the pin.  The argument ``x`` can be anything that converts to a boolean.\n   If it converts to ``True``, the pin is set to state '1', otherwise it is set\n   to state '0'.  The behaviour of this method depends on the mode of the pin:\n\n     - ``Pin.IN`` - The value is stored in the output buffer for the pin.  The\n       pin state does not change, it remains in the high-impedance state.  The\n       stored value will become active on the pin as soon as it is changed to\n       ``Pin.OUT`` or ``Pin.OPEN_DRAIN`` mode.\n     - ``Pin.OUT`` - The output buffer is set to the given value immediately.\n     - ``Pin.OPEN_DRAIN`` - If the value is '0' the pin is set to a low voltage\n       state.  Otherwise the pin is set to high-impedance state.\n\n   When setting the value this method returns ``None``.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef WLAN.scan():\n    '''\n    Scan for the available wireless networks.\n\n    Scanning is only possible on STA interface. Returns list of tuples with\n    the information about WiFi access points:\n\n        (ssid, bssid, channel, RSSI, authmode, hidden)\n\n    *bssid* is hardware address of an access point, in binary form, returned as\n    bytes object. You can use `ubinascii.hexlify()` to convert it to ASCII form.\n\n    There are five values for authmode:\n\n        * 0 -- open\n        * 1 -- WEP\n        * 2 -- WPA-PSK\n        * 3 -- WPA2-PSK\n        * 4 -- WPA/WPA2-PSK\n\n    and two for hidden:\n\n        * 0 -- visible\n        * 1 -- hidden\n    '''\n\n\n-=-+-=-\n","completion": "List[Tuple[str, bytes, int, int, int, int]]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef sizeof(struct, layout_type=NATIVE, /):\n    '''\n   Return size of data structure in bytes. The *struct* argument can be\n   either a structure class or a specific instantiated structure object\n   (or its aggregate field).\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef loads(str):\n    '''\n   Parse the JSON *str* and return an object.  Raises :exc:`ValueError` if the\n   string is not correctly formed.\n    '''\n\n\n-=-+-=-\n","completion": "dict"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef urandom(n):\n    '''\n   Return a bytes object with *n* random bytes. Whenever possible, it is\n   generated by the hardware random number generator.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef ilistdir([dir]):\n    '''\n   This function returns an iterator which then yields tuples corresponding to\n   the entries in the directory that it is listing.  With no argument it lists the\n   current directory, otherwise it lists the directory given by *dir*.\n\n   The tuples have the form *(name, type, inode[, size])*:\n\n    - *name* is a string (or bytes if *dir* is a bytes object) and is the name of\n      the entry;\n    - *type* is an integer that specifies the type of the entry, with 0x4000 for\n      directories and 0x8000 for regular files;\n    - *inode* is an integer corresponding to the inode of the file, and may be 0\n      for filesystems that don't have such a notion.\n    - Some platforms may return a 4-tuple that includes the entry's *size*.  For\n      file entries, *size* is an integer representing the size of the file\n      or -1 if unknown.  Its meaning is currently undefined for directory\n      entries.\n    '''\n\n\n-=-+-=-\n","completion": "Iterator[Tuple[Union[str, bytes], int, int, Optional[int]]]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef statvfs(path):\n    '''\n   Get the status of a fileystem.\n\n   Returns a tuple with the filesystem information in the following order:\n\n        * ``f_bsize`` -- file system block size\n        * ``f_frsize`` -- fragment size\n        * ``f_blocks`` -- size of fs in f_frsize units\n        * ``f_bfree`` -- number of free blocks\n        * ``f_bavail`` -- number of free blocks for unprivileged users\n        * ``f_files`` -- number of inodes\n        * ``f_ffree`` -- number of free inodes\n        * ``f_favail`` -- number of free inodes for unprivileged users\n        * ``f_flag`` -- mount flags\n        * ``f_namemax`` -- maximum filename length\n\n   Parameters related to inodes: ``f_files``, ``f_ffree``, ``f_avail``\n   and the ``f_flags`` parameter may return ``0`` as they can be unavailable\n   in a port-specific implementation.\n    '''\n\n\n-=-+-=-\n","completion": "Tuple[int, int, int, int, int, int, int, int, int, int]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef dupterm(stream_object, index=0, /):\n    '''\n   Duplicate or switch the MicroPython terminal (the REPL) on the given `stream`-like\n   object. The *stream_object* argument must be a native stream object, or derive\n   from ``uio.IOBase`` and implement the ``readinto()`` and\n   ``write()`` methods.  The stream should be in non-blocking mode and\n   ``readinto()`` should return ``None`` if there is no data available for reading.\n\n   After calling this function all terminal output is repeated on this stream,\n   and any input that is available on the stream is passed on to the terminal input.\n\n   The *index* parameter should be a non-negative integer and specifies which\n   duplication slot is set.  A given port may implement more than one slot (slot 0\n   will always be available) and in that case terminal input and output is\n   duplicated on all the slots that are set.\n\n   If ``None`` is passed as the *stream_object* then duplication is cancelled on\n   the slot given by *index*.\n\n   The function returns the previous stream-like object in the given slot.\n    '''\n\n\n-=-+-=-\n","completion": "IO"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef readblocks(block_num, buf):\n    '''\n                readblocks(block_num, buf, offset)\n\n        The first form reads aligned, multiples of blocks.\n        Starting at the block given by the index *block_num*, read blocks from\n        the device into *buf* (an array of bytes).\n        The number of blocks to read is given by the length of *buf*,\n        which will be a multiple of the block size.\n\n        The second form allows reading at arbitrary locations within a block,\n        and arbitrary lengths.\n        Starting at block index *block_num*, and byte offset within that block\n        of *offset*, read bytes from the device into *buf* (an array of bytes).\n        The number of bytes to read is given by the length of *buf*.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef socket.recvfrom(bufsize):\n    '''\n  Receive data from the socket. The return value is a pair *(bytes, address)* where *bytes* is a\n  bytes object representing the data received and *address* is the address of the socket sending\n  the data.\n    '''\n\n\n-=-+-=-\n","completion": "Tuple[bytes, Tuple[str, int]]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef ussl.wrap_socket(sock, server_side=False, keyfile=None, certfile=None, cert_reqs=CERT_NONE, ca_certs=None, do_handshake=True):\n    '''\n   Takes a `stream` *sock* (usually usocket.socket instance of ``SOCK_STREAM`` type),\n   and returns an instance of ssl.SSLSocket, which wraps the underlying stream in\n   an SSL context. Returned object has the usual `stream` interface methods like\n   ``read()``, ``write()``, etc.\n   A server-side SSL socket should be created from a normal socket returned from\n   :meth:`~usocket.socket.accept()` on a non-SSL listening server socket.\n\n   - *do_handshake* determines whether the handshake is done as part of the ``wrap_socket``\n     or whether it is deferred to be done as part of the initial reads or writes\n     (there is no ``do_handshake`` method as in CPython).\n     For blocking sockets doing the handshake immediately is standard. For non-blocking\n     sockets (i.e. when the *sock* passed into ``wrap_socket`` is in non-blocking mode)\n     the handshake should generally be deferred because otherwise ``wrap_socket`` blocks\n     until it completes. Note that in AXTLS the handshake can be deferred until the first\n     read or write but it then blocks until completion.\n\n   Depending on the underlying module implementation in a particular\n   :term:`MicroPython port`, some or all keyword arguments above may be not supported.\n    '''\n\n\n-=-+-=-\n","completion": "ssl.SSLSocket"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef exit(retval=0, /):\n    '''\n   Terminate current program with a given exit code. Underlyingly, this\n   function raise as `SystemExit` exception. If an argument is given, its\n   value given as an argument to `SystemExit`.\n    '''\n\n\n-=-+-=-\n","completion": "NoReturn"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef atexit(func):\n    '''\n   Register *func* to be called upon termination.  *func* must be a callable\n   that takes no arguments, or ``None`` to disable the call.  The ``atexit``\n   function will return the previous value set by this function, which is\n   initially ``None``.\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef open(name, mode='r', **kwargs):\n    '''\n    Open a file. Builtin ``open()`` function is aliased to this function.\n    All ports (which provide access to file system) are required to support\n    *mode* parameter, but support for other arguments vary by port.\n    '''\n\n\n-=-+-=-\n","completion": "IOBase"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef sub(regex_str, replace, string, count=0, flags=0, /):\n    '''\n   Compile *regex_str* and search for it in *string*, replacing all matches\n   with *replace*, and returning the new string.\n\n   *replace* can be a string or a function.  If it is a string then escape\n   sequences of the form ``\\<number>`` and ``\\g<number>`` can be used to\n   expand to the corresponding group (or an empty string for unmatched groups).\n   If *replace* is a function then it must take a single argument (the match)\n   and should return a replacement string.\n\n   If *count* is specified and non-zero then substitution will stop after\n   this many substitutions are made.  The *flags* argument is ignored.\n\n   Note: availability of this function depends on :term:`MicroPython port`.\n    '''\n\n\n-=-+-=-\n","completion": "str"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef match.start([index]):\n    '''\n            match.end([index])\n\n   Return the index in the original string of the start or end of the\n   substring group that was matched.  *index* defaults to the entire\n   group, otherwise it will select a group.\n\n   Note: availability of these methods depends on :term:`MicroPython port`.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Pin.irq(handler=None, trigger=(Pin.IRQ_FALLING | Pin.IRQ_RISING), *, priority=1, wake=None, hard=False):\n    '''\n   Configure an interrupt handler to be called when the trigger source of the\n   pin is active.  If the pin mode is ``Pin.IN`` then the trigger source is\n   the external value on the pin.  If the pin mode is ``Pin.OUT`` then the\n   trigger source is the output buffer of the pin.  Otherwise, if the pin mode\n   is ``Pin.OPEN_DRAIN`` then the trigger source is the output buffer for\n   state '0' and the external pin value for state '1'.\n\n   The arguments are:\n\n     - ``handler`` is an optional function to be called when the interrupt\n       triggers. The handler must take exactly one argument which is the\n       ``Pin`` instance.\n\n     - ``trigger`` configures the event which can generate an interrupt.\n       Possible values are:\n\n       - ``Pin.IRQ_FALLING`` interrupt on falling edge.\n       - ``Pin.IRQ_RISING`` interrupt on rising edge.\n       - ``Pin.IRQ_LOW_LEVEL`` interrupt on low level.\n       - ``Pin.IRQ_HIGH_LEVEL`` interrupt on high level.\n\n       These values can be OR'ed together to trigger on multiple events.\n\n     - ``priority`` sets the priority level of the interrupt.  The values it\n       can take are port-specific, but higher values always represent higher\n       priorities.\n\n     - ``wake`` selects the power mode in which this interrupt can wake up the\n       system.  It can be ``machine.IDLE``, ``machine.SLEEP`` or ``machine.DEEPSLEEP``.\n       These values can also be OR'ed together to make a pin generate interrupts in\n       more than one power mode.\n\n     - ``hard`` if true a hardware interrupt is used. This reduces the delay\n       between the pin change and the handler being called. Hard interrupt\n       handlers may not allocate memory; see :ref:`isr_rules`.\n       Not all ports support this argument.\n\n   This method returns a callback object.\n\nThe following methods are not part of the core Pin API and only implemented on certain ports.\n    '''\n\n\n-=-+-=-\n","completion": "Callable[..., Any]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef phase(z):\n    '''\n   Returns the phase of the number ``z``, in the range (-pi, +pi].\n    '''\n\n\n-=-+-=-\n","completion": "float"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef rect(r, phi):\n    '''\n   Returns the complex number with modulus ``r`` and phase ``phi``.\n    '''\n\n\n-=-+-=-\n","completion": "float"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef deepsleep([time_ms]):\n    '''\n   Stops execution in an attempt to enter a low power state.\n\n   If *time_ms* is specified then this will be the maximum time in milliseconds that\n   the sleep will last for.  Otherwise the sleep can last indefinitely.\n\n   With or without a timeout, execution may resume at any time if there are events\n   that require processing.  Such events, or wake sources, should be configured before\n   sleeping, like `Pin` change or `RTC` timeout.\n\n   The precise behaviour and power-saving capabilities of lightsleep and deepsleep is\n   highly dependent on the underlying hardware, but the general properties are:\n\n   * A deepsleep may not retain RAM or any other state of the system (for example\n     peripherals or network interfaces).  Upon wake execution is resumed from the main\n     script, similar to a hard or power-on reset. The `reset_cause()` function will\n     return `machine.DEEPSLEEP` and this can be used to distinguish a deepsleep wake\n     from other resets.\n    '''\n\n\n-=-+-=-\n","completion": "NoReturn"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Pin.value([x]):\n    '''\n   This method allows to set and get the value of the pin, depending on whether\n   the argument ``x`` is supplied or not.\n\n   If the argument is omitted then this method gets the digital logic level of\n   the pin, returning 0 or 1 corresponding to low and high voltage signals\n   respectively.  The behaviour of this method depends on the mode of the pin:\n\n     - ``Pin.IN`` - The method returns the actual input value currently present\n       on the pin.\n     - ``Pin.OUT`` - The behaviour and return value of the method is undefined.\n     - ``Pin.OPEN_DRAIN`` - If the pin is in state '0' then the behaviour and\n       return value of the method is undefined.  Otherwise, if the pin is in\n       state '1', the method returns the actual input value currently present\n       on the pin.\n\n   If the argument is supplied then this method sets the digital logic level of\n   the pin.  The argument ``x`` can be anything that converts to a boolean.\n   If it converts to ``True``, the pin is set to state '1', otherwise it is set\n   to state '0'.  The behaviour of this method depends on the mode of the pin:\n\n     - ``Pin.IN`` - The value is stored in the output buffer for the pin.  The\n       pin state does not change, it remains in the high-impedance state.  The\n       stored value will become active on the pin as soon as it is changed to\n       ``Pin.OUT`` or ``Pin.OPEN_DRAIN`` mode.\n     - ``Pin.OUT`` - The output buffer is set to the given value immediately.\n     - ``Pin.OPEN_DRAIN`` - If the value is '0' the pin is set to a low voltage\n       state.  Otherwise the pin is set to high-impedance state.\n\n   When setting the value this method returns ``None``.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Signal.value([x]):\n    '''\n   This method allows to set and get the value of the signal, depending on whether\n   the argument ``x`` is supplied or not.\n\n   If the argument is omitted then this method gets the signal level, 1 meaning\n   signal is asserted (active) and 0 - signal inactive.\n\n   If the argument is supplied then this method sets the signal level. The\n   argument ``x`` can be anything that converts to a boolean. If it converts\n   to ``True``, the signal is active, otherwise it is inactive.\n\n   Correspondence between signal being active and actual logic level on the\n   underlying pin depends on whether signal is inverted (active-low) or not.\n   For non-inverted signal, active status corresponds to logical 1, inactive -\n   to logical 0. For inverted/active-low signal, active status corresponds\n   to logical 0, while inactive - to logical 1.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef UART.read([nbytes]):\n    '''\n   Read characters.  If ``nbytes`` is specified then read at most that many bytes,\n   otherwise read as much data as possible. It may return sooner if a timeout\n   is reached. The timeout is configurable in the constructor.\n\n   Return value: a bytes object containing the bytes read in.  Returns ``None``\n   on timeout.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef UART.write(buf):\n    '''\n   Write the buffer of bytes to the bus.\n\n   Return value: number of bytes written or ``None`` on timeout.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef I2C.readinto(buf, nack=True, /):\n    '''\n   Reads bytes from the bus and stores them into *buf*.  The number of bytes\n   read is the length of *buf*.  An ACK will be sent on the bus after\n   receiving all but the last byte.  After the last byte is received, if *nack*\n   is true then a NACK will be sent, otherwise an ACK will be sent (and in this\n   case the peripheral assumes more bytes are going to be read in a later call).\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef I2S.readinto(buf):\n    '''\n  Read audio samples into the buffer specified by ``buf``.  ``buf`` must support the buffer protocol, such as bytearray or array.\n  \"buf\" byte ordering is little-endian.  For Stereo format, left channel sample precedes right channel sample. For Mono format,\n  the left channel sample data is used.\n  Returns number of bytes read\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef opt_level([level]):\n    '''\n   If *level* is given then this function sets the optimisation level for subsequent\n   compilation of scripts, and returns ``None``.  Otherwise it returns the current\n   optimisation level.\n\n   The optimisation level controls the following compilation features:\n\n   - Assertions: at level 0 assertion statements are enabled and compiled into the\n     bytecode; at levels 1 and higher assertions are not compiled.\n   - Built-in ``__debug__`` variable: at level 0 this variable expands to ``True``;\n     at levels 1 and higher it expands to ``False``.\n   - Source-code line numbers: at levels 0, 1 and 2 source-code line number are\n     stored along with the bytecode so that exceptions can report the line number\n     they occurred at; at levels 3 and higher line numbers are not stored.\n\n   The default optimisation level is usually level 0.\n    '''\n\n\n-=-+-=-\n","completion": "int"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef disable_irq():\n    '''\n   Disable interrupt requests.\n   Returns the previous IRQ state: ``False``/``True`` for disabled/enabled IRQs\n   respectively.  This return value can be passed to enable_irq to restore\n   the IRQ to its original state.\n    '''\n\n\n-=-+-=-\n","completion": "bool"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef ADC.read_timed(buf, timer):\n    '''\n   Read analog values into ``buf`` at a rate set by the ``timer`` object.\n\n   ``buf`` can be bytearray or array.array for example.  The ADC values have\n   12-bit resolution and are stored directly into ``buf`` if its element size is\n   16 bits or greater.  If ``buf`` has only 8-bit elements (eg a bytearray) then\n   the sample resolution will be reduced to 8 bits.\n\n   ``timer`` should be a Timer object, and a sample is read each time the timer\n   triggers.  The timer must already be initialised and running at the desired\n   sampling frequency.\n\n   To support previous behaviour of this function, ``timer`` can also be an\n   integer which specifies the frequency (in Hz) to sample at.  In this case\n   Timer(6) will be automatically configured to run at the given frequency.\n\n   Example using a Timer object (preferred way)::\n\n       adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n       tim = pyb.Timer(6, freq=10)         # create a timer running at 10Hz\n       buf = bytearray(100)                # creat a buffer to store the samples\n       adc.read_timed(buf, tim)            # sample 100 values, taking 10s\n\n   Example using an integer for the frequency::\n\n       adc = pyb.ADC(pyb.Pin.board.X19)    # create an ADC on pin X19\n       buf = bytearray(100)                # create a buffer of 100 bytes\n       adc.read_timed(buf, 10)             # read analog values into buf at 10Hz\n                                           #   this will take 10 seconds to finish\n       for val in buf:                     # loop over all values\n           print(val)                      # print the value out\n\n   This function does not allocate any heap memory. It has blocking behaviour:\n   it does not return to the calling program until the buffer is full.\n    '''\n\n\n-=-+-=-\n","completion": "bytearray"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef CAN.recv(fifo, list=None, *, timeout=5000):\n    '''\n   Receive data on the bus:\n\n     - *fifo* is an integer, which is the FIFO to receive on\n     - *list* is an optional list object to be used as the return value\n     - *timeout* is the timeout in milliseconds to wait for the receive.\n\n   Return value: A tuple containing four values.\n\n     - The id of the message.\n     - A boolean that indicates if the message is an RTR message.\n     - The FMI (Filter Match Index) value.\n     - An array containing the data.\n\n   If *list* is ``None`` then a new tuple will be allocated, as well as a new\n   bytes object to contain the data (as the fourth element in the tuple).\n\n   If *list* is not ``None`` then it should be a list object with a least four\n   elements.  The fourth element should be a memoryview object which is created\n   from either a bytearray or an array of type 'B' or 'b', and this array must\n   have enough room for at least 8 bytes.  The list object will then be\n   populated with the first three return values above, and the memoryview object\n   will be resized inplace to the size of the data and filled in with that data.\n   The same list and memoryview objects can be reused in subsequent calls to\n   this method, providing a way of receiving data without using the heap.\n   For example::\n\n        buf = bytearray(8)\n        lst = [0, 0, 0, memoryview(buf)]\n        # No heap memory is allocated in the following call\n        can.recv(0, lst)\n    '''\n\n\n-=-+-=-\n","completion": "Tuple[int, bool, int, memoryview]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef SPI.recv(recv, *, timeout=5000):\n    '''\n   Receive data on the bus:\n\n     - ``recv`` can be an integer, which is the number of bytes to receive,\n       or a mutable buffer, which will be filled with received bytes.\n     - ``timeout`` is the timeout in milliseconds to wait for the receive.\n\n   Return value: if ``recv`` is an integer then a new buffer of the bytes received,\n   otherwise the same buffer that was passed in to ``recv``.\n    '''\n\n\n-=-+-=-\n","completion": "bytes"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef Lock.acquire():\n    '''\n    Wait for the lock to be in the unlocked state and then lock it in an atomic\n    way.  Only one task can acquire the lock at any one time.\n\n    This is a coroutine.\n    '''\n\n\n-=-+-=-\n","completion": "asyncio.Lock"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef open_connection(host, port):\n    '''\n    Open a TCP connection to the given *host* and *port*.  The *host* address will be\n    resolved using `socket.getaddrinfo`, which is currently a blocking call.\n\n    Returns a pair of streams: a reader and a writer stream.\n    Will raise a socket-specific ``OSError`` if the host could not be resolved or if\n    the connection could not be made.\n\n    This is a coroutine.\n    '''\n\n\n-=-+-=-\n","completion": "Coroutine[Tuple, Any, Any]"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef writeblocks(block_num, buf):\n    '''\n                writeblocks(block_num, buf, offset)\n\n        The first form writes aligned, multiples of blocks, and requires that the\n        blocks that are written to be first erased (if necessary) by this method.\n        Starting at the block given by the index *block_num*, write blocks from\n        *buf* (an array of bytes) to the device.\n        The number of blocks to write is given by the length of *buf*,\n        which will be a multiple of the block size.\n\n        The second form allows writing at arbitrary locations within a block,\n        and arbitrary lengths.  Only the bytes being written should be changed,\n        and the caller of this method must ensure that the relevant blocks are\n        erased via a prior ``ioctl`` call.\n        Starting at block index *block_num*, and byte offset within that block\n        of *offset*, write bytes from *buf* (an array of bytes) to the device.\n        The number of bytes to write is given by the length of *buf*.\n\n        Note that implementations must never implicitly erase blocks if the offset\n        argument is specified, even if it is zero.\n    '''\n\n\n-=-+-=-\n","completion": "None"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef match.group(index):\n    '''\n   Return matching (sub)string. *index* is 0 for entire match,\n   1 and above for each capturing group. Only numeric groups are supported.\n    '''\n\n\n-=-+-=-\n","completion": "str"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef WLANWiPy.irq(*, handler, wake):\n    '''\n    Create a callback to be triggered when a WLAN event occurs during ``machine.SLEEP``\n    mode. Events are triggered by socket activity or by WLAN connection/disconnection.\n\n        - *handler* is the function that gets called when the IRQ is triggered.\n        - *wake* must be ``machine.SLEEP``.\n\n    Returns an IRQ object.\n    '''\n\n\n-=-+-=-\n","completion": "Any"}
{"prompt": "What MicroPython type is returned according to the following docstring, written as a python type hint.\n\n\ndef random.choice():\n    '''\n    Chooses and returns one item at random from *sequence* (tuple, list or any object that supports the subscript operation).\n    '''\n\n\n-=-+-=-\n","completion": "Any"}
